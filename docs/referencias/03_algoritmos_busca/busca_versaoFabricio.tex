\documentclass[landscape,pdftex]{jomislides}

\slidesmag{5} % escala, qto maior maiores ser„o as letras/figras/etc.

%\centerslidesfalse

\usepackage{algorithmic}

%
% Slides
% ======
%


\begin{document}

%\input{autorHeaders}

\title{Busca em EspaÁo de Estados} 
\author{FabrÌcio Barth}
\institution{Insper}
\date{MarÁo de 2022}

\SlideHeader{}
            {Agentes AutÙnomos e Aprendizagem por ReforÁo}
\SlideFooter{\theslidepartheading $\;$ --- $\;$ \theslideheading}
            {\theslide}

\vpagecolor[white]{white}


\subtitle{}

\maketitle


%
%
%   IntroduÁ„o
%
%
\begin{PartSlide}{\textbf{IntroduÁ„o}}
\end{PartSlide}

\begin{Slide}{Agente orientado a \textbf{meta}}
  \begin{itemize}
  \item O projetista n„o determina um mapeamento entre percepÁıes e
    aÁıes, mas determina que objetivo o agente deve alcanÁar

  \item … necess·rio que o prÛprio agente construa um plano de aÁıes
    que atinjam seu objetivo

    (como se o prÛprio agente construÌsse seu programa)
    
  \item Exemplos: o agente aspirador de pÛ, um agente motorista de
    t·xi, uma sonda espacial, ...
  \end{itemize}
\end{Slide}

\begin{Slide}{O que È \textbf{busca}?}
  \begin{itemize}
  \item O mundo do agente tem um conjunto de \emph{estados} possÌveis (muitas
    vezes este conjunto È infinito)
  \item Existem \emph{transiÁıes} entre os estados do mundo, formando um grafo.
  \item S„o utilizados \emph{algoritmos} para encontrar um caminho neste grafo
    \begin{itemize}
    \item partindo do estado inicial (atual)
    \item atÈ o estado objetivo
    \end{itemize}
  \end{itemize}

\end{Slide}

\begin{Slide}{Exemplo do \textbf{aspirador de pÛ}}
  \begin{itemize}
  \item Um robÙ aspirador de pÛ deve limpar uma casa com duas
    posiÁıes. As operaÁıes que ele sabe executar s„o:
    \begin{itemize}
    \item sugar
    \item ir para a posiÁ„o da esquerda
    \item ir para a posiÁ„o da direita
    \end{itemize}
  \item Como o aspirador pode montar um plano para limpar a casa se
    inicialmente ele esta na posiÁ„o direita e as duas posiÁıes tÍm
    sujeira?
    \begin{itemize}
    \item Quais os estados possÌveis do mundo do aspirador e as transiÁıes?
    \end{itemize}

  \end{itemize}

  \textbf{Estados} possÌveis:
  \begin{center}
    \includegraphics[width=.7\textwidth]{figuras/fig03-02.pdf}
  \end{center}

  \newpage
  \textbf{EspaÁo de busca}
  \begin{center}
    \includegraphics[width=\textwidth]{figuras/fig03-06.pdf}
  \end{center}
\end{Slide}

\begin{Slide}{Por que \textbf{estados}?}
  \begin{itemize}
  {\small  
  \item As informaÁıes do mundo real s„o absurdamente complexas, È
    praticamente impossÌvel model·-las todas
    \begin{itemize}
    \item No exemplo do aspirador, o mundo dele tem v·rias outras
      informaÁıes: a cor do tapete, se È dia, de que material o
      aspirador È feito, quanto ele tem de energia, como È o nome do/a
      propriet·rio/a, ....
    \end{itemize}

  \item A noÁ„o de estado È utilizada para \emph{abstrair} esses detalhes e
    considerar somente o que È relevante para a soluÁ„o do problema

  \item O mesmo se d· com as operaÁıes modeladas: s„o abstraÁıes das
    operaÁıes reais (ir para a posiÁ„o da direita implica em v·rias
    outras operaÁıes).
  }
  \end{itemize}

\end{Slide}


\begin{Slide}{Exemplo do \textbf{homem, o lobo, o carneiro e o cesto
      de alface.}}
  \begin{itemize}
  \item Uma pessoa, um lobo, um carneiro e um cesto de alface est„o ‡
    beira de um rio. Dispondo de um barco no qual pode carregar apenas
    um dos outros trÍs, a pessoa deve transportar tudo para a outra
    margem. Determine uma sÈrie de travessias que respeite a seguinte
    condiÁ„o: em nenhum momento devem ser deixados juntos e sozinhos o
    lobo e o carneiro ou o carneiro e o cesto de alface.
  \end{itemize}
\end{Slide}

\begin{Slide}{Busca como \textbf{desenvolvimento} de software}
  \begin{itemize}
  \item No desenvolvimento de um software para resolver um problema, o
    projetista pode optar por v·rias paradigmas de modelagem do problema:
    \begin{itemize}
    \item O sistema È modelado por procedimentos que alteram os dados
      de entrada
    \item O sistema È modelado por funÁıes 
    \item O sistema È modelado por predicados
    \item O sistema È modelado por objetos
    \item ...
    \end{itemize}
    
    \newpage

  \item Busca È mais uma forma de modelar um problema:
    \begin{itemize}
    \item Definir os estados
    \item Definir as transiÁıes
    \item Escolher um algoritmo de busca
    \end{itemize}


  \end{itemize}
\end{Slide}


\begin{Slide}{ExercÌcio}
  O que {È} 
  \begin{itemize}
  \item estado 
  \item transiÁ„o
  \item estado meta e
  \item custo da soluÁ„o encontrada
  \end{itemize}
  para os seguintes problemas
  \begin{itemize}
    \newpage
  \item 8-Puzzle

      \begin{center}
        \includegraphics[width=.7\textwidth]{figuras/fig03-04.pdf}
      \end{center}

      \newpage

  \item Encontrar um caminho da cidade ``i'' atÈ  ``x''
      \begin{center}
        \includegraphics[width=.8\textwidth]{figuras/mapa.pdf}
      \end{center}
  \end{itemize}
\end{Slide}


%
%
%   Busca
%
%

\begin{PartSlide}{Algoritmos de Busca ``\textbf{Cega}''}
\end{PartSlide}


\begin{Slide}{\textbf{¡rvore} de busca}
  \begin{itemize}
  \item Coloca-se o estado inicial como nodo raiz
  \item Cada operaÁ„o sobre o estado raiz gera um novo nodo (chamado
    de \emph{sucessor})
  \item Repete-se este processo para os novos nodos atÈ gerar o nodo
    que representa o estado meta

  \item \emph{EstratÈgia} de busca: que nodo escolher para expandir

  \item Exemplo: (fazer as ·rvores para o exemplo do aspirador e do
    homem no rio)

  \end{itemize}
\end{Slide}


\begin{Slide}{\textbf{EstratÈgias} de busca}
  \begin{itemize}
  \item Busca em \emph{largura}: o nodo de \textbf{menor} profundidade mais a
    esquerda È escolhido para gerar sucessores

  \item Busca em \emph{profundidade}: o nodo de \textbf{maior} profundidade mais a
    esquerda È escolhido para gerar sucessores
  \end{itemize}
\end{Slide}


\begin{Slide}{Algoritmo de busca em \textbf{largura}}
\begin{algorithmic} 
\STATE \textbf{function} BL(Estado $inicial$): Nodo
\STATE \textbf{Fila} $abertos$
\STATE $abertos$.\textbf{add}(\textbf{new} Nodo($inicial$))
\WHILE{$abertos$.\textbf{size}() $> 0$}
    \STATE Nodo $n \gets abertos$.\textbf{removeFirst}()
    \IF{$n$.\textbf{getEstado}().\textbf{ÈMeta()}}
       \STATE \textbf{return} $n$
    \ENDIF   
    \STATE $abertos$.\textbf{append}($n$.\textbf{sucessores}())
\ENDWHILE
\STATE \textbf{return null}
\end{algorithmic}
\end{Slide}



\begin{Slide}{\textbf{CritÈrios} de comparaÁ„o entre os algoritmos}
  \begin{itemize}
  \item \emph{Completo}: o algoritmo encontra a soluÁ„o se ela
    existir
  \item \emph{”timo}: o algoritmo encontra a soluÁ„o de menor custo
  \item \emph{Tempo}: quanto tempo o algoritmo leva para encontrar a
    soluÁ„o no pior caso
  \item \emph{EspaÁo}: quanto de memÛria o algoritmo ocupa
  \end{itemize}
\end{Slide}



\begin{Slide}{\textbf{An·lise} do algoritmo BL}
  \begin{itemize}
  \item Completo: sim 
  \item ”timo:  sim, para problemas de custo uniforme
  \item Tempo: explorar $O(b^d)$ nodos

  \begin{itemize}
    \item $b$ = fator de ramificaÁ„o
    \item $d$ = profundidade do estado meta
    \item $O(b^d) = 1+b+b^2+b^3+....+b^d$
  \end{itemize} 

  \item EspaÁo: guardar $O(b^d)$ nodos.
  \end{itemize}
\end{Slide}


\begin{Slide}{Exemplo de \textbf{complexidade}}
  \begin{tabular}{r r l l}
    \textbf{Prof.} & \textbf{Nodos} & \textbf{Tempo} & \textbf{MemÛria} \\
    \hline
    0  & 1 & 1ms & 100 bytes \\ 
    2  & 111 & 0,1 seg & 11 Kbytes \\ 
    4  & 11.111 & 11 seg & 1 Mbyte\\ 
    6  & $10^6$ & 18 min & 111 Mbytes\\ 
    8  & $10^8$ & 31 horas & 11 Gbytes\\ 
    12 & $10^{12}$ & 35 anos & 111 Tbytes\\ 
    14 & $10^{14}$ & 3500 anos & 11.111 Tbytes\\
    \hline
  \end{tabular}
  
  ($b = 10$, 1000 nodos por segundo, 100 bytes por nodo)

\end{Slide}

\begin{Slide}{\textbf{Nodos} da ·rvore}
	\begin{itemize}
		\item Cada nodo tem
		\begin{itemize}
			\item o estado que representa
			\item o nodo pai
			\item o operador que o gerou
			\item sua profundidade na ·rvore de busca
			\item o custo de ter sido gerado (dentado por $g$)
			\item opcionalmente, os nodos sucessores
		\end{itemize}
		\item (fazer a figura)
	\end{itemize}
\end{Slide}



\begin{Slide}{\textbf{EstratÈgias} de poda da ·rvore de busca}
	\begin{itemize}
		\item Um nodo n„o gera um sucessor igual a seu pai
		\item Um nodo n„o gera um sucessor igual a um de seus ascendentes
		\item Um nodo n„o gera um sucessor que j· exista na ·rvore de busca
		
		
		\newpage
		
		\item Detalhes de implementaÁ„o:
		\begin{itemize}
			\item Verificar se um estado j· esta na ·rvore pode levar muito
			tempo
			\begin{itemize}
				\item imagine uma ·rvore com milhares de estados do jogo de
				xadrez, cada novo estado deve ser comparado com outros
				milhares de estados!
			\end{itemize}
			\item Ter uma tabela \emph{hash} (que tem tempo Ûtimo de
			consulta) para saber se determinado nodo existe na ·rvore
		\end{itemize}
	\end{itemize}
\end{Slide}


\begin{Slide}{Algoritmo de busca em \textbf{profundidade}}
\begin{algorithmic} 
\STATE \textbf{function} BP(Estado $inicial$, int $m$): Nodo
{\small
\STATE \textbf{Pilha} $abertos$
\STATE $abertos$.\textbf{add}(\textbf{new} Nodo($inicial$))
\WHILE{$abertos$.\textbf{size}() $> 0$}
    \STATE Nodo $n \gets abertos$.\textbf{removeTopo}()
    \IF{$n$.\textbf{getEstado}().\textbf{ÈMeta()}}
       \STATE \textbf{return} $n$
    \ENDIF
    \IF{$n$.\textbf{getProfundidade}() $< m$}
       \STATE $abertos$.\emph{insert}($n$.\textbf{sucessores}())
    \ENDIF
\ENDWHILE
\STATE \textbf{return null}
}
\end{algorithmic}
\end{Slide}


\begin{Slide}{\textbf{An·lise} do algoritmo BP}
  \begin{itemize}
  \item Completo:  n„o (caso a meta esteja em profundidade maior que $m$)

    Se $m = \infty$, È completo se o espaÁo de estados È finito e
    existe poda para n„o haver loops entre as operaÁıes

  \item ”timo:  n„o 
  \item Tempo: explorar $O(b^m)$ nodos 
    (ruim se $m$ È muito maior que $d$) 

  \item EspaÁo: guardar $O(bm)$ nodos.
    (em profundidade 12, ocupa 12 Kbytes!)
  \end{itemize}
\end{Slide}


\begin{Slide}{Algoritmo de busca em profundidade \textbf{iterativo}}
\begin{algorithmic} 
\STATE \textbf{function} BPI(Estado $inicial$): Nodo
\STATE int $p \gets 1$
\LOOP
    \STATE Nodo $n \gets$ \emph{BP}($inicial$, $p$)
    \IF{$n \neq$ \textbf{null}}
       \STATE \textbf{return} $n$
    \ENDIF   
    \STATE $p \gets p + 1$
\ENDLOOP
\end{algorithmic}
\end{Slide}


\begin{Slide}{\textbf{An·lise} do algoritmo BPI}
  \begin{itemize}
  \item Completo:  sim 
  \item ”timo:  sim, se todas as aÁıes tem o mesmo custo

  \item Tempo: explorar $O(b^d)$ nodos 
  \item EspaÁo: guardar $O(bd)$ nodos.
  \end{itemize}
\end{Slide}



%\begin{Slide}{Algoritmo de busca \textbf{Bidirecional}}
%\begin{algorithmic} 
%\STATE \textbf{function} BBD(Estado $inicial$, $meta$): Nodo
%{\footnotesize
%\STATE \textbf{List} $abertosCima$, $abertosBaixo$
%\STATE $abertosCima$.\textbf{add}(\textbf{new} Nodo($inicial$))
%\STATE $abertosBaixo$.\textbf{add}(\textbf{new} Nodo($meta$))
%\WHILE{$abertosCima$.\textbf{size}() $> 0$ \textbf{or} $abertosBaixo$.\textbf{size}() $> 0$}
%    \STATE \COMMENT{verifica lista de cima}
%    \STATE Nodo $n \gets abertosCima$.\textbf{removeFirst}()
%    \STATE \textbf{if} {$n$.\textbf{getEstado}() $\in abertosBaixo$}
%    \textbf{then} \textbf{return} $meta$ \textbf{end if}
%    \STATE $abertosCima$.\textbf{append}($n$.\textbf{sucessores}())
%    \STATE \COMMENT{verifica lista de baixo}
%    \STATE $n \gets abertosBaixo$.\textbf{removeFirst}()
%    \STATE \textbf{if} {$n$.\textbf{getEstado}() $\in abertosCima$}
%    \textbf{then} \textbf{return} $meta$  \textbf{end if}
%    \STATE $abertosBaixo$.\textbf{append}($n$.\emph{antecessores}())
%\ENDWHILE
%\STATE \textbf{return null}
%}
%\end{algorithmic}
%\end{Slide}


%\begin{Slide}{\textbf{An·lise} do algoritmo BBD}
%  \begin{itemize}
%  \item Completo: sim 
%  \item ”timo: sim 
%  \item Tempo: explorar $O(b^{d/2})$ nodos 
%  \item EspaÁo: guardar $O(b^{d/2})$ nodos
%
%  \item ObservaÁ„o: deve ser possÌvel gera antecessores
%  \end{itemize}
%\end{Slide}

\begin{Slide}{Algoritmo de busca de \textbf{custo uniforme}}
\begin{algorithmic} 
\STATE \textbf{function} BCU(Estado $inicial$): Nodo
\STATE \textbf{Set} $abertos$ ordenados por custo
\STATE $abertos$.\textbf{add}(\textbf{new} Nodo($inicial$))
\WHILE{$abertos$.\textbf{size}() $> 0$}
    \STATE Nodo $n \gets abertos$.\textbf{removeFirst}()
    \IF{$n$.\textbf{getEstado}().\textbf{ÈMeta()}}
       \STATE \textbf{return} $n$
    \ENDIF   
    \STATE $abertos$.\textbf{append}($n$.\textbf{sucessores}())
\ENDWHILE
\STATE \textbf{return null}
\end{algorithmic}
\end{Slide}

\begin{Slide}{Algoritmo de busca de \textbf{custo uniforme}}
\begin{itemize}
\item Expande nÛs de acordo com o custo.
\item Se custo = profundidade do nÛ ent„o temos uma busca em largura.
\end{itemize}
\end{Slide}

\begin{Slide}{\textbf{Resumo}}

%  \begin{center}
%    \includegraphics[width=.8\textwidth]{figuras/arvoreResumo.pdf}
%  \end{center}

  \begin{tabular}{l c c c c}
    & \textbf{BL} & \textbf{BP} & \textbf{BPI} & \textbf{BCU} \\
    \hline
    \emph{Completo} & sim & n„o & sim & sim \\
    \emph{”timo} & sim & n„o & sim & sim \\
    \emph{Tempo} & $O(b^d)$ & $O(b^m)$ & $O(b^d)$ & $O(b^d)$\\ 
    \emph{EspaÁo} & $O(b^d)$ & $O(bm)$ & $O(bd)$ & $O(b^d)$\\
    \hline
  \end{tabular}

\end{Slide}


%
%
%  Busca heurÌstica
%
%
\begin{PartSlide}{Algoritmos de Busca ``\textbf{Inteligente}''}
\end{PartSlide}

\begin{Slide}{\textbf{Exemplo}: ir de ``h'' para ``o'' (com BL)}
  \begin{center}
    \includegraphics[width=.6\textwidth]{figuras/mapa.pdf}
  \end{center}
  A ·rvore de busca gerada È ``inteligente''?
\end{Slide}

\begin{Slide}{\textbf{HeurÌstica}}
  \begin{itemize}
  \item HeurÌstica: \emph{Estimativa} de custo atÈ a meta. (denotado
    pela funÁ„o $h : Estados \to Reais$)

  \item No exemplo das cidades, poderia ser a dist‚ncia em linha reta.

  \item Algoritmo de \emph{busca gananciosa}: retira de abertos sempre
    o nodo com menor estimativa de custo (menor $h$).

    \begin{itemize}
    \item Refazer a busca de um caminho entre ``h'' e ``o''. 

    \item Refazer a busca de um caminho entre ``i'' e ``x''. 
     

    \item \textbf{Fazer a tabela de $h$ para os dois casos}.
    
    \end{itemize}

\newpage

    \begin{itemize}
    \item Refazer a busca de um caminho entre ``h'' e ``o''. 
      \textbf{Ûtimo}!

    \item Refazer a busca de um caminho entre ``i'' e ``x''. 
      \textbf{n„o} Ûtimo!

    \end{itemize}
  \end{itemize}
\end{Slide}


\begin{Slide}{Busca \textbf{A*}}
  \begin{itemize}
  \item \textbf{IdÈia}: Evitar expandir caminhos que \textbf{j·} est„o
    muito caros mas tambÈm considerar os que tÍm menor expectativa de
    custo.

  \item Utilizar na escolha de um nodo da lista de abertos
    \begin{itemize}
    \item tanto a estimativa de custo de um nodo ($h(n)$)
    \item quanto o custo acumulado para chegar no nodo ($g(n)$)
    \end{itemize}

    $f(n) = g(n) + h(n)$

  \item Refazer a busca de um caminho entre ``i'' e ``x'' utilizando
    $f$.

  \end{itemize}
\end{Slide}

\begin{Slide}{Algoritmo de busca \textbf{A*}}
\begin{algorithmic} 
\STATE \textbf{function} BA*(Estado $inicial$): Nodo
\STATE \textbf{PriorityList}($f$) $abertos$ 
\COMMENT{lista ordenada por $f$}
\STATE $abertos$.\textbf{add}(\textbf{new} Nodo($inicial$))
\WHILE{$abertos$.\textbf{size}() $> 0$}
    \STATE Nodo $n \gets abertos$.\textbf{removeFirst}()
    \IF{$n$.\textbf{getEstado}().\textbf{ÈMeta()}}
       \STATE \textbf{return} $n$
    \ENDIF   
    \STATE $abertos$.\textbf{append}($n$.\textbf{sucessores}())
\ENDWHILE
\STATE \textbf{return null}
\end{algorithmic}
\end{Slide}


\begin{Slide}{\textbf{Propriedades} da funÁ„o $h$}
  \begin{itemize}
  \item Supondo que o valor de $h$, no exemplo das cidades, È dados
    por 10 * a dist‚ncia em linha reta.

  \item O algoritmo A* ainda È Ûtimo?

  \item $h(n)$: estimativa de custo de $n$ atÈ a meta
  \item $h^*(n)$: custo real de $n$ atÈ a meta

  \item Se $h(n) \leq h^*(n)$, ent„o $h$ È \emph{admissÌvel}.

  \item Se $h$ È admissÌvel, o algoritmo A* È Ûtimo!

  \end{itemize}
\end{Slide}


\begin{Slide}{\textbf{An·lise} do algoritmo A*}
  \begin{itemize}
  \item Completo: \textbf{sim} 
  \item ”timo: \textbf{sim} (se $h$ È admissÌvel)
  \item Tempo: explorar $O(b^d)$ nodos no pior caso (quando a
    heurÌstica È ``do contra'')

  \item EspaÁo: guardar $O(b^d)$ nodos no pior caso.
  \end{itemize}
\end{Slide}


\begin{Slide}{\textbf{ExercÌcio}}
  \begin{itemize}
  \item Determine uma heurÌstica para o problema 8-Puzzle e verifique
    se È admissÌvel.

    \begin{center}
      \includegraphics[width=.7\textwidth]{figuras/fig03-04.pdf}
    \end{center}
    \newpage
    \begin{itemize}
    \item $h_1$: n˙mero de peÁas fora do lugar
    \item $h_2$: dist‚ncia de cada peÁa de seu lugar
    \item $h_3$: peÁas fora da formaÁ„o de caracol
%    \item $h_4 = h_1 + h_2 + h_3 + h_4$
    \end{itemize}    
  \end{itemize}
\end{Slide}


%\begin{Slide}{\textbf{Complexidade} no problema
%    8-puzzle}
%
%{\small
%  \begin{center}
%    \begin{tabular}{r|r r r|r r r}
%      \hline
%          & \multicolumn{3}{c|}{n˙mero de abertos} &
%          \multicolumn{3}{c}{fator ramificaÁ„o} \\\hline
%      $d$ & BPI    & A*($h_1$) & A*($h_2$) & BPI    & A*($h_1$) & A*($h_2$) \\\hline
%      2   & 10     & 6         & 6     & 2.45 & 1.79 & 1.79\\
%      4   & 112    & 13        & 12    & 2.87 & 1.48 & 1.45\\
%      8   & 6384   & 39        & 25    & 2.80 & 1.33 & 1.24\\
%      12  & 364404 & 227       & 73    & 2.78 & 1.42 & 1.24\\
%      16  & --     & 1301      & 211   & --   & 1.45 & 1.25\\
%      20  & --     & 7276      & 676   & --   & 1.47 & 1.27\\
%      24  & --     & 39135     & 1641  & --   & 1.48 & 1.26\\
%      \hline
%    \end{tabular}
%  \end{center}
%}
%\end{Slide}
%


\begin{Slide}{\textbf{ExercÌcio}}

  \begin{itemize}
  \item Determine uma heurÌstica para o problema das 8-raÌnhas e
    verifique se È admissÌvel.

    \begin{center}
      \includegraphics[width=.4\textwidth]{figuras/fig03-05.pdf}
    \end{center}
    
\newpage
    
    \begin{itemize}
    \item $h$: soma do n˙mero de ataques
    \end{itemize}
  \end{itemize}
\end{Slide}



\begin{Slide}{Algoritmo \textbf{Subida da Montanha-1}}
  \textbf{IdÈia}: escolher sempre um sucessor melhor

(``\textit{subir sempre}'').
 
\begin{algorithmic} 
\STATE \textbf{function} BSM-1(Estado $inicial$): Estado
\STATE Estado $atual \gets inicial$
\LOOP
    \STATE $prox \gets $ melhor sucessor de $atual$ (segundo $h$)
    \IF[sem sucessor melhor]{$h(prox) \geq h(atual)$}
       \STATE \textbf{return} $atual$
    \ENDIF
    \STATE $atual \gets prox$
\ENDLOOP
\end{algorithmic}
\end{Slide}

\begin{Slide}{\textbf{An·lise} do algoritmo BSM-1}
  \begin{itemize}
  \item N„o mantÈm a ·rvore (logo, n„o pode retornar o caminho que
    usou para chegar ‡ meta).

  \item Completo:  \textbf{n„o} (problema de \emph{m·ximos locais})
  \item ”timo:  n„o se aplica
  \item Tempo:  \textbf{?}
  \item EspaÁo:  \textbf{nada}!
  \end{itemize}
\end{Slide}


\begin{Slide}{Algoritmo \textbf{Subida da Montanha-2}}
{\footnotesize
\begin{algorithmic} 
\STATE \textbf{function} BSM-2(Estado $inicial$): Estado
\STATE Estado $atual \gets inicial$
\LOOP
    \STATE $prox \gets $ melhor sucessor de $atual$ (segundo $h$)
    \IF[sem sucessor melhor]{$h(prox) \geq h(atual)$}
       \IF{$atual$.\textbf{ÈMeta}()}
          \STATE \textbf{return} $atual$
       \ELSE
          \STATE $atual \gets$ estado gerado aleatÛriamente
       \ENDIF
    \ELSE
       \STATE $atual \gets prox$
    \ENDIF
\ENDLOOP
\end{algorithmic}
}
\end{Slide}


\begin{Slide}{\textbf{An·lise} do algoritmo BSM-2}
  \begin{itemize}
  \item Completo:  \textbf{sim} (se a geraÁ„o de estados
    aleatÛrios distribuir normalmente os estados gerados)
  \item ”timo:  n„o se aplica
  \item Tempo:  \textbf{?}
  \item EspaÁo:  \textbf{nada}!
  \end{itemize}
\end{Slide}


\begin{Slide}{Material de \textbf{consulta}}
  \begin{itemize}
  \item CapÌtulos 3 e 4 do livro do Russell \& Norvig
  \end{itemize}
\end{Slide}


\end{document}

